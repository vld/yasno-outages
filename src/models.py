from pydantic import BaseModel, Field
from typing import Literal
from datetime import datetime, timedelta
from enum import Enum


class NotificationType(str, Enum):
    PLAN_NEW = "PlanNew"
    PLAN_CHANGED = "PlanChanged"
    PLAN_STABLE = "PlanStable"


class Slot(BaseModel):
    start: int
    end: int
    type: Literal["NotPlanned", "Definite"]

    def __str__(self):
        start_dt = (datetime.min + timedelta(minutes=self.start)).strftime("%H:%M")
        end_dt = (datetime.min + timedelta(minutes=self.end)).strftime("%H:%M")
        text_type = "–Ñ —Å–≤—ñ—Ç–ª–æ üí°" if self.type == "NotPlanned" else "–ù–µ–º–∞—î —Å–≤—ñ—Ç–ª–∞ ‚ùå"
        return f"{text_type} –∑ {start_dt} –¥–æ {end_dt}"


class OutagesPlan(BaseModel):
    date: datetime
    slots: list[Slot]
    updated_on: datetime | None = Field(default=None, alias="updatedOn")


class PlanInfo(BaseModel):
    updated_on: datetime = Field(alias="updatedOn")
    today: OutagesPlan
    tomorrow: OutagesPlan


class NotificationMessage(BaseModel):
    notification_type: NotificationType
    plan: OutagesPlan

    def __str__(self) -> str:
        plan_date_str = self.plan.date.strftime("%d.%m.%Y")
        match self.notification_type:
            case NotificationType.PLAN_CHANGED:
                header = f"–ó–º—ñ–Ω–∏ –≤ –ø–ª–∞–Ω—ñ –≤—ñ–¥–∫–ª—é—á–µ–Ω—å –Ω–∞ {plan_date_str}:\n"
            case NotificationType.PLAN_NEW:
                header = f"–ù–æ–≤–∏–π –ø–ª–∞–Ω –≤—ñ–¥–∫–ª—é—á–µ–Ω—å –Ω–∞ {plan_date_str}:\n"
            case NotificationType.PLAN_STABLE:
                header = f"–ü–ª–∞–Ω –≤—ñ–¥–∫–ª—é—á–µ–Ω—å –Ω–∞ {plan_date_str} –∑–∞–ª–∏—à–∏–≤—Å—è –±–µ–∑ –∑–º—ñ–Ω:\n"
            case _:
                header = "–ù–µ–≤—ñ–¥–æ–º–∏–π —Ç–∏–ø –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è.\n"

        if self.plan.slots:
            slots_info = "\n".join(str(slot) for slot in self.plan.slots)
        else:
            slots_info = "–ù–µ–º–∞—î —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è."
        return f"{header}{slots_info}"
